include::./includes/attributes.adoc[]

= Quarkus Roq Data

Quarkus Roq Data is a Quarkus extension that register JSON/YAML files as CDI beans, and available from Qute templates, in a type-safe way in your project.

CAUTION: Roq Data is already included as part of the Roq Static Site Generator extension `io.quarkiverse.roq:quarkus-roq`, Follow <<standalone-installation>> section to use it standalone.

== Data Mapping

You can add JSON or YAML files to your project's `data` directory.

NOTE: The data file can use `.json`, `.yml`, or `.yaml` extensions.

[source,json]
.mountain.json
----
{
    "name": "Lhotse",
    "elevation": 8516
}
----

To use the data in your Java code, you have two options:

=== 1. Use a Java class mapping.

[source,java]
.Mountain.java
----
import io.quarkiverse.roq.data.runtime.annotations.DataMapping;

@DataMapping("mountain") // <1>
public record Mountain(String name, Integer elevation) {}
----
<1> The filename of the data file without the extension.

Then inject the `Mountain` record into a resource class.

[source,java]
.Resource.java
----
import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

@Path("/site")
public class Resource {

    @Inject
    Mountain mountain;

    @GET
    public String getMountain() {
        return mountain.toString();
    }
}
----


Access the resource using the following URL: `http://localhost:8080/site`. The output should be `Quarkus Site - Quarkus Site generated by Roq`.


=== 2. Use JsonObject dynamic mapping

It is also possible to directly access the data without having a class mapping. In this case you can inject a named `io.vertx.core.json.JsonObject` in your code:

[source,java]
.Resource.java
----
import jakarta.inject.Inject;
import jakarta.inject.Named;import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

@Path("/site")
public class Resource {

    @Inject
    @Named("mountain") // <1>
    JsonObject mountain;

    @GET
    public String getMountain() {
        return mountain.toString();
    }
}
----
<1> The filename of the data file without the extension.


== Mapping data file as a array

If your data file root element is an array.

[source,json]
.mountains.json
----
[
    {
        "name": "Lhotse",
        "elevation": 8516
    },
    {
        "name": "Everest",
        "elevation": 8849
    }
]
----

You also have two options to map it.

=== 1. Use a parent Java class mapping.


You could create a parent record as shown below:

[source,java]
.Mountains.java
----
import java.util.List;
import io.quarkiverse.roq.data.runtime.annotations.DataMapping;

@DataMapping(value = "mountains", parentArray = true) // <1>
public record Mountains(List<Mountain> list) { // <2>

}
----

<1> The `parentArray` attribute is set to `true` to indicate that the root element of the data file is an array.
<2> The class aimed to map the data file must have a constructor that accepts a single parameter of type `List<T>`, where `T` is the type of the elements in the array.

CAUTION: The class annotated with `@DataMapping(parentArray=true)` must have a constructor that accepts a single parameter of type `List<T>`, where `T` is the type of the elements in the array.

With the above configuration, the `Mountains` record will have a list of `Mountain` records and can be injected via CDI.

=== 2. Use JsonArray dynamic mapping

It is also possible to directly access the data without having a class mapping. In this case you can inject a named `io.vertx.core.json.JsonArray` in your code:

[source,java]
.Resource.java
----
import jakarta.inject.Inject;
import jakarta.inject.Named;import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

@Path("/site")
public class Resource {

    @Inject
    @Named("mountains") // <1>
    JsonArray mountains;

    @GET
    public String getMountains() {
        return mountains.toString();
    }
}
----
<1> The filename of the data file without the extension.


== From a Qute template

Since generated data beans are named, it is possible to access them from any Qute template:

[source,html]
----
{#for mountain in cdi:mountains}
  <li>{mountains.name}: {mountains.elevation}</li> // <1>
{/for}
----

<1> A Value Resolver already exists for `JsonObject` allowing you to directly access attributes.

NOTE: For type-safety, use a `@DataMapping` bean instead and access it using the Qute `cdi` namespace.

[[standalone-installation]]
== Standalone installation

NOTE: It is included as part of the Roq Static Site Generator extension `io.quarkiverse.roq:quarkus-roq`. You can also use it standalone.

If you want to use this extension standalone, you need to add the `io.quarkiverse.roq:quarkus-roq-data` extension first to your build file.

For instance, with Maven, add the following dependency to your POM file:

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>io.quarkiverse.roq</groupId>
    <artifactId>quarkus-roq-data</artifactId>
    <version>{project-version}</version>
</dependency>
----


[[extension-configuration-reference]]
== Extension Configuration Reference

include::includes/quarkus-roq-data.adoc[leveloffset=+1, opts=optional]